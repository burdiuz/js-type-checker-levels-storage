{"version":3,"file":"index.min.js","sources":["node_modules/@actualwave/has-own/has-own.js","source/levels.js","node_modules/@actualwave/map-of-sets/index.js","source/storage.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","import hasOwn from '@actualwave/has-own';\n\n/**\n * Do not check or report type inconsistency\n */\nexport const REPORT_NEVER = 'never';\n/**\n * Report type inconsistency once, i.e. record all types and report new\n */\nexport const REPORT_ONCE = 'once';\n/**\n * Report whenever type is inconsistent with initial\n */\nexport const REPORT_ALL = 'all';\n\nconst REPORT_KEY = Symbol('type-checkers:report-level');\nconst PROPERTY_REPORT_KEY = Symbol('type-checkers:property-report-level');\n\nlet globalReportingLevel = REPORT_ALL;\n\nexport const validateReportingLevel = (level) => {\n  switch (level) {\n    case REPORT_NEVER:\n    case REPORT_ONCE:\n      return level;\n    default:\n      return REPORT_ALL;\n  }\n};\n\nexport const setGlobalReportingLevel = (level) => {\n  globalReportingLevel = validateReportingLevel(level);\n};\n\nexport const getGlobalReportingLevel = () => globalReportingLevel;\n\nconst setTargetGeneralReportingLevel = (target, level) => {\n  if (level) {\n    target[REPORT_KEY] = validateReportingLevel(level);\n  } else {\n    delete target[REPORT_KEY];\n  }\n};\n\nconst setTargetPropertyReportingLevel = (target, perPropertyLevels) => {\n  if (!perPropertyLevels) {\n    delete target[PROPERTY_REPORT_KEY];\n    return;\n  }\n\n  target[PROPERTY_REPORT_KEY] = Object.keys(perPropertyLevels).reduce(\n    (levels, prop) => {\n      levels[prop] = validateReportingLevel(perPropertyLevels[prop]);\n      return levels;\n    },\n    {}\n  );\n};\n\nexport const setReportingLevel = (target, generalLevel, perPropertyLevels) => {\n  setTargetGeneralReportingLevel(target, generalLevel);\n  setTargetPropertyReportingLevel(target, perPropertyLevels);\n};\n\nconst getTargetReportingLevel = (target, key) => {\n  if (hasOwn(target[PROPERTY_REPORT_KEY], key)) {\n    return target[PROPERTY_REPORT_KEY][key];\n  }\n\n  return target[REPORT_KEY];\n};\n\nexport const getReportingLevel = (target, key) => {\n  let level = getTargetReportingLevel(target, key);\n\n  if (!level) {\n    level = getTargetReportingLevel(target.constructor, key);\n  }\n\n  return level || getGlobalReportingLevel();\n};\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass MapOfSets {\n  constructor() {\n    this.storage = new Map();\n  }\n  /**\r\n   * Check if key exists\r\n   * @param {*} key\r\n   */\n\n\n  has(key) {\n    const values = this.storage.get(key);\n    return values && values.size;\n  }\n  /**\r\n   * Check if value exists for key\r\n   * @param {*} key\r\n   * @param {*} value\r\n   */\n\n\n  hasValue(key, value) {\n    const values = this.storage.get(key);\n    return values && values.has(value);\n  }\n  /**\r\n   * Get Set of values for key\r\n   * @param {*} key\r\n   */\n\n\n  get(key) {\n    return this.storage.get(key);\n  }\n  /**\r\n   * List values for key, returns empty array if no key nor values stored\r\n   * @param {*} key\r\n   */\n\n\n  list(key) {\n    const values = this.storage.get(key);\n    return values ? Array.from(values) : [];\n  }\n  /**\r\n   * Call callback for each value of each key\r\n   *  callback (value:*, key:*, storage:*):void\r\n   * @param {Function} callback\r\n   */\n\n\n  forEach(callback) {\n    this.storage.forEach((values, key) => values.forEach(value => callback(value, key, this)));\n  }\n  /**\r\n   * Call callback function for each value of specified key\r\n   *  callback (value:*, key:*, storage:*):void\r\n   * @param {*} key\r\n   * @param {Function} callback\r\n   */\n\n\n  eachValue(key, callback) {\n    const values = this.storage.get(key);\n\n    if (values) {\n      values.forEach(value => callback(value, key, this));\n    }\n  }\n  /**\r\n   * Add to new value to key.\r\n   * @param {*} key\r\n   * @param {*} value\r\n   */\n\n\n  add(key, value) {\n    if (!value) return;\n    const values = this.storage.get(key);\n\n    if (values) {\n      values.add(value);\n    } else {\n      this.storage.set(key, new Set([value]));\n    }\n  }\n  /**\r\n   * Replace all values for key\r\n   * @param {*} key\r\n   * @param {Set} types\r\n   */\n\n\n  set(key, values) {\n    if (!values || values.size === 0) {\n      this.remove(key);\n      return;\n    }\n\n    this.storage.set(key, new Set(values));\n  }\n  /**\r\n   * Remove all values for key\r\n   * @param {*} key\r\n   */\n\n\n  remove(key) {\n    this.storage.delete(key);\n  }\n  /**\r\n   * Remove single value from key\r\n   * @param {*} key\r\n   * @param {*} value\r\n   */\n\n\n  removeValue(key, value) {\n    const values = this.storage.get(key);\n\n    if (values) {\n      values.delete(value);\n\n      if (!values.size) {\n        this.remove(key);\n      }\n    }\n  }\n  /**\r\n   * Clone all key-value stores\r\n   */\n\n\n  clone() {\n    const target = new MapOfSets();\n    this.storage.forEach((values, key) => target.set(key, new Set(values)));\n    return target;\n  }\n\n}\nconst createMapOfSets = () => new MapOfSets();\n\nexports.MapOfSets = MapOfSets;\nexports.createMapOfSets = createMapOfSets;\nexports.default = MapOfSets;\n//# sourceMappingURL=index.js.map\n","import MapOfSets from '@actualwave/map-of-sets';\n\nimport {\n  REPORT_NEVER,\n  REPORT_ONCE,\n  REPORT_ALL,\n  getReportingLevel,\n  validateReportingLevel,\n} from './levels';\n\n/**\n *\n * @param {any} key\n * @param {Set} target\n * @param {Set} source\n */\nexport const defaultMergeStrategy = (key, target, source) => {\n  source.forEach((type) => {\n    if (!target.has(type)) {\n      target.add(type);\n    }\n  });\n\n  return target;\n};\n\nclass TypeInfoStorage extends MapOfSets {\n  /**\n   * Add to type information for specified key.\n   * @param {*} key\n   * @param {*} type\n   * @param {Number} level\n   */\n  add(key, type, level) {\n    if (!type) return;\n\n    switch (level) {\n      case REPORT_NEVER:\n        this.remove(key);\n        break;\n      case REPORT_ONCE:\n        super.add(key, type);\n        break;\n      case REPORT_ALL:\n      default:\n        {\n          const types = this.storage.get(key);\n\n          if (!types || !types.size) {\n            this.storage.set(key, new Set([type]));\n          }\n        }\n        break;\n    }\n  }\n\n  addFor(key, type, target) {\n    this.add(key, type, getReportingLevel(target, key));\n  }\n\n  /**\n   * Replace types information for specific key\n   * @param {*} key\n   * @param {Set} types\n   * @param {Number} level\n   */\n  set(key, types, level) {\n    if (!types || types.size === 0 || level === REPORT_NEVER) {\n      this.remove(key);\n      return;\n    }\n\n    super.set(key, types);\n  }\n\n  /**\n   *\n   * @param {*} key\n   * @param {Set} types\n   * @param {Object} target\n   */\n  setFor(key, types, target) {\n    return this.set(key, types, getReportingLevel(target, key));\n  }\n\n  clone() {\n    const target = new TypeInfoStorage();\n    this.storage.forEach((types, key) => target.set(key, new Set(types)));\n\n    return target;\n  }\n\n  /**\n   * Copy types from current storage to storage passed as first argument.\n   * @param {Map} storage\n   * @param {Object} [target]\n   * @param {Function} [mergeStrategy]\n   */\n  copyTo(storage, target, mergeStrategy = defaultMergeStrategy) {\n    this.storage.forEach((types, key) => {\n      const level = validateReportingLevel(target && getReportingLevel(target, key));\n\n      switch (level) {\n        case REPORT_ALL:\n        case REPORT_ONCE:\n          if (storage.has(key)) {\n            storage.set(key, mergeStrategy(key, storage.get(key), types, level), level);\n          } else {\n            storage.set(key, new Set(types));\n          }\n          break;\n        case REPORT_NEVER:\n        default:\n          break;\n      }\n    });\n\n    return storage;\n  }\n}\n\nexport const createTypesStorage = () => new TypeInfoStorage();\n\nexport default TypeInfoStorage;\n"],"names":["Object","defineProperty","exports","value","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","REPORT_NEVER","REPORT_ONCE","REPORT_ALL","REPORT_KEY","Symbol","PROPERTY_REPORT_KEY","globalReportingLevel","validateReportingLevel","level","getGlobalReportingLevel","getTargetReportingLevel","key","getReportingLevel","constructor","MapOfSets","[object Object]","this","storage","Map","values","get","size","Array","from","callback","forEach","add","set","Set","remove","delete","defaultMergeStrategy","source","type","TypeInfoStorage","types","mergeStrategy","generalLevel","perPropertyLevels","keys","reduce","levels","prop"],"mappings":"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"}