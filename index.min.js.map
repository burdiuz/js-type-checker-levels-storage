{"version":3,"file":"index.min.js","sources":["node_modules/@actualwave/has-own/has-own.js","source/levels.js","source/storage.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","import hasOwn from '@actualwave/has-own';\n\n/**\n * Do not check or report type inconsistency\n */\nexport const REPORT_NEVER = 'never';\n/**\n * Report type inconsistency once, i.e. record all types and report new\n */\nexport const REPORT_ONCE = 'once';\n/**\n * Report whenever type is inconsistent with initial\n */\nexport const REPORT_ALL = 'all';\n\nconst REPORT_KEY = Symbol('type-checkers:report-level');\nconst PROPERTY_REPORT_KEY = Symbol('type-checkers:property-report-level');\n\nlet globalReportingLevel = REPORT_ALL;\n\nexport const validateReportingLevel = (level) => {\n  switch (level) {\n    case REPORT_NEVER:\n    case REPORT_ONCE:\n      return level;\n    default:\n      return REPORT_ALL;\n  }\n};\n\nexport const setGlobalReportingLevel = (level) => {\n  globalReportingLevel = validateReportingLevel(level);\n};\n\nexport const getGlobalReportingLevel = () => globalReportingLevel;\n\nconst setTargetGeneralReportingLevel = (target, level) => {\n  if (level) {\n    target[REPORT_KEY] = validateReportingLevel(level);\n  } else {\n    delete target[REPORT_KEY];\n  }\n};\n\nconst setTargetPropertyReportingLevel = (target, perPropertyLevels) => {\n  if (!perPropertyLevels) {\n    delete target[PROPERTY_REPORT_KEY];\n    return;\n  }\n\n  target[PROPERTY_REPORT_KEY] = Object.keys(perPropertyLevels).reduce(\n    (levels, prop) => {\n      levels[prop] = validateReportingLevel(perPropertyLevels[prop]);\n      return levels;\n    },\n    {}\n  );\n};\n\nexport const setReportingLevel = (target, generalLevel, perPropertyLevels) => {\n  setTargetGeneralReportingLevel(target, generalLevel);\n  setTargetPropertyReportingLevel(target, perPropertyLevels);\n};\n\nconst getTargetReportingLevel = (target, key) => {\n  if (hasOwn(target[PROPERTY_REPORT_KEY], key)) {\n    return target[PROPERTY_REPORT_KEY][key];\n  }\n\n  return target[REPORT_KEY];\n};\n\nexport const getReportingLevel = (target, key) => {\n  let level = getTargetReportingLevel(target, key);\n\n  if (!level) {\n    level = getTargetReportingLevel(target.constructor, key);\n  }\n\n  return level || getGlobalReportingLevel();\n};\n","import {\n  REPORT_NEVER,\n  REPORT_ONCE,\n  REPORT_ALL,\n  getReportingLevel,\n  validateReportingLevel,\n} from './levels';\n\n/**\n *\n * @param {any} key\n * @param {Set} target\n * @param {Set} source\n */\nconst defaultMergeStrategy = (key, target, source) => {\n  if (!source || !target) {\n    return source || target;\n  }\n\n  source.forEach((type) => {\n    if (!target.has(type)) {\n      target.add(type);\n    }\n  });\n\n  return target;\n};\n\nclass TypeInfoStorage {\n  constructor() {\n    this.storage = new Map();\n  }\n\n  has(key) {\n    const info = this.storage.get(key);\n\n    return info && info.size;\n  }\n\n  hasType(key, type) {\n    const info = this.storage.get(key);\n\n    return info && info.has(type);\n  }\n\n  /**\n   *\n   * @param {*} key\n   * @param {Function} callback\n   */\n  get(key, callback) {\n    const info = this.storage.get(key);\n\n    if (info) {\n      info.forEach((type) => callback(key, type));\n    }\n  }\n\n  /**\n   * Add to type information for specified key.\n   * @param {*} key\n   * @param {*} type\n   * @param {Number} level\n   */\n  add(key, type, level) {\n    if (!type) return;\n\n    switch (level) {\n      case REPORT_NEVER:\n        this.storage.delete(key);\n        break;\n      case REPORT_ONCE:\n        {\n          const types = this.storage.get(key);\n\n          if (types) {\n            if (!types.has(type)) {\n              types.add(type);\n            }\n          } else {\n            this.storage.set(key, new Set([type]));\n          }\n        }\n        break;\n      case REPORT_ALL:\n      default:\n        {\n          const types = this.storage.get(key);\n\n          if (!types || !types.size) {\n            this.storage.set(key, new Set([type]));\n          }\n        }\n        break;\n    }\n  }\n\n  addFor(key, type, target) {\n    this.add(key, type, getReportingLevel(target, key));\n  }\n\n  /**\n   * Replace types information for specific key\n   * @param {*} key\n   * @param {Set} types\n   * @param {Number} level\n   */\n  set(key, types, level) {\n    if (!types || types.size === 0 || level === REPORT_NEVER) {\n      this.storage.delete(key);\n      return;\n    }\n\n    this.storage.set(key, types);\n  }\n\n  /**\n   *\n   * @param {*} key\n   * @param {Set} types\n   * @param {Object} target\n   */\n  setFor(key, types, target) {\n    return this.set(key, types, getReportingLevel(target, key));\n  }\n\n  clone() {\n    const target = new TypeInfoStorage();\n    this.storage.forEach((types, key) => target.set(key, new Set(types)));\n\n    return target;\n  }\n\n  /**\n   * Copy types from current storage to storage passed as first argument.\n   * @param {Map} storage\n   * @param {Object} [target]\n   * @param {Function} [mergeStrategy]\n   */\n  copyTo(storage, target, mergeStrategy = defaultMergeStrategy) {\n    this.storage.forEach((types, key) => {\n      const level = validateReportingLevel(target && getReportingLevel(target, key));\n\n      switch (level) {\n        case REPORT_ALL:\n        case REPORT_ONCE:\n          if (storage.has(key)) {\n            storage.set(key, mergeStrategy(key, storage.get(key), types, level), level);\n          } else {\n            storage.set(key, new Set(types));\n          }\n          break;\n        case REPORT_NEVER:\n        default:\n          break;\n      }\n    });\n\n    return storage;\n  }\n}\n\nexport const createTypesStorage = () => new TypeInfoStorage();\n\nexport default TypeInfoStorage;\n"],"names":["Object","defineProperty","exports","value","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","REPORT_NEVER","REPORT_ONCE","REPORT_ALL","REPORT_KEY","Symbol","PROPERTY_REPORT_KEY","globalReportingLevel","validateReportingLevel","level","getGlobalReportingLevel","getTargetReportingLevel","key","getReportingLevel","constructor","defaultMergeStrategy","source","forEach","type","add","TypeInfoStorage","storage","Map","info","this","get","size","callback","delete","types","set","Set","mergeStrategy","generalLevel","perPropertyLevels","keys","reduce","levels","prop"],"mappings":"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"}